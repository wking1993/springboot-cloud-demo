1、Guava Cache本地缓存：
  1.1 优点：
    a)本地缓存，读取效率高，不受网络因素影像
    b)拥有丰富的功能，操作简单
    c)线程安全
  1.2 缺点：
    a)缓存为本地缓存，不能持久化数据
    b)单机缓存，受机器内存限制，应用重启数据会丢失
    c)分布式部署时无法保证数据的一致性
  1.3 基于时间的两种回收方式：
    a)expireAfterAccess(long, TimeUnit):当缓存项在制定的时间段内，没有被读或写就会被回收，这种回收策略类似于基于容量回收策略；
    b)expireAfterWrite(long, TimeUnit):当缓存项在指定的时间段内没有更新就会被回收，如果我们认为缓存数据在一段时间后，不再可用，那么可以使用该策略。
  1.4 显示移除的三种方式：
    a)CacheBuilder.invalidate(key):单个移除
    b)CacheBuilder.invalidateAll(keys):批量移除
    c)CacheBuilder.invalidateAll():移除全部
  1.5 通过设置最大容量来进行移除的方式，当超出制定的容量后缓存将尝试回收最近没有使用或者总体上很少使用的缓存项：
    CacheBuilder.newBuilder().maximumSize(10)
2、Redis缓存
  2.1 Redis是一个开源的使用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
      Redis是一个高性能的key-value数据库，同时支持多种存储类型，包括String(字符串)、List(链表)、Set(集合)、Zset(有序集合)、Hash(哈希)
  2.2 Spring Cache缓存数据的注解：
    a) @Cacheable:用于查询的时候缓存数据；
    b) @CachePut:用于对数据修改的时候，修改缓存中的数据；
    c) @CacheEvict:用于对数据删除的时候清除缓存中的数据；
3、缓存穿透
  所有请求都不能命中缓存；
  缓存穿透就是调用方每次传来的缓存key都是缓存中不存在的key值，这样每次查询都会去查询数据库，会导致数据库压力增大，这样缓存就失去了意义；
  解决方案：
  a) 如果查询数据库也为空的时候，把这个key也缓存起来；
  b) 可以用缓存key的规则来进行限制，在查询之前判断这个key做认证，看是否符合规范，当不符合规范时，直接返回默认值；
  c) 布隆过滤器
  	通过布隆过滤器实现对缓存key的检验，需要将所有可能缓存的数据的key值Hash到一个足够大的BitSet中，在缓存之前先从布隆过滤器中判断这个key是否存在，然后在做对应的操作。
4、缓存雪崩
  缓存雪崩就是在某一时刻，大量缓存同时失效导致所有请求都去查询数据库，导致数据库压力过大，然后挂掉的情况。
  缓存穿透比较严重的时候，也会导致缓存雪崩的发生。
  解决方案：
  a) 缓存存储高可用，比如Redis集群；
  b) 缓存失效时间要设计好，不同的数据有不同的有效期，尽可能保证不要再同一时间失效，统一去规划有效期，让失效时间分布均匀；
  c) 对于一些热门数据的持续读取，这种缓存数据可以采用定时更新的方式来刷新缓存
  d) 服务限流和接口限流，如果服务和接口都有限流机制，就算缓存全部失效了，但是请求的总量是有限制的，可以在承受范围内，虽然短时间内系统响应较慢，但不至于挂掉，影响整个系统；
  e) 从数据库获取缓存需要的数据时加锁控制，本地锁或者分布式锁都可以。当所有请求都不能命中缓存，即缓存穿透，这时候如果并发量大，可能导致缓存雪崩，
  	我们可以在对数据库查询的地方进行加锁控制，不要让所有请求都过去，这样可以保证存储服务不挂掉。
  
